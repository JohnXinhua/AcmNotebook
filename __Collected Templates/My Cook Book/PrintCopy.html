<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>D:\ACM\Code_I_Use\CollectedFromOthers\I use it\PrintCopy.cpp</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="generator" content="Code::Blocks Exporter plugin" />
<style type="text/css">
<!--
body { color: #000000; background-color: #FFFFFF; }
.style11 { color: #000000; background-color: #FFFFFF; }
.style64 { color: #C8C8C8; }
.style72 { color: #C8C8C8; }
.style75 { color: #C8C8C8; }
.style1 { color: #A0A0A0; }
.style23 { color: #A0A0A0; }
.style65 { color: #A0A0A0; }
.style87 { color: #A0A0A0; }
.style2 { color: #BEBEE6; }
.style66 { color: #BEBEE6; }
.style3 { color: #8080FF; font-weight: bold; }
.style24 { color: #8080FF; font-weight: bold; }
.style67 { color: #8080FF; font-weight: bold; }
.style88 { color: #8080FF; font-weight: bold; }
.style15 { color: #8080FF; font-weight: bold; }
.style79 { color: #8080FF; font-weight: bold; }
.style17 { color: #008080; }
.style81 { color: #008080; }
.style18 { color: #800000; }
.style82 { color: #800000; }
.style4 { color: #F000F0; }
.style68 { color: #F0C8F0; }
.style5 { color: #0000A0; font-weight: bold; }
.style69 { color: #8787C8; font-weight: bold; }
.style16 { color: #00A000; font-weight: bold; }
.style80 { color: #9AC89A; font-weight: bold; }
.style19 { color: #BE00BE; font-weight: bold; }
.style83 { color: #BE89BE; font-weight: bold; }
.style6 { color: #0000FF; }
.style12 { color: #0000FF; }
.style70 { color: #BEBEFF; }
.style76 { color: #BEBEFF; }
.style7 { color: #E0A000; }
.style71 { color: #E0CE9F; }
.style8 { color: #000000; }
.style9 { color: #00A000; }
.style73 { color: #84A084; }
.style10 { color: #FF0000; }
.style74 { color: #FFC8C8; }
.style34 { color: #000000; background-color: #80FFFF; font-weight: bold; }
.style35 { color: #FFFFFF; background-color: #FF0000; font-weight: bold; }
.style50 { color: #404080; font-style: italic; }
.style114 { color: #8585AC; font-style: italic; }
--></style></head>
<body>
<pre>
<code><span style="font: 10pt Courier New;"><span class="style11">Eulear Tour And Circuit
Sliding Window
Kadane Algorithm </span><span class="style4">1D
</span><span class="style11">Kadane Algorithm </span><span class="style4">2D
</span><span class="style11">Kadane Algorithm </span><span class="style4">3D
</span><span class="style11">SuffixArray </span><span class="style10">(</span><span class="style11">nlogn</span><span class="style10">)

</span><span class="style11">Eulear Tour And Circuit
</span><span class="style10">=============================
</span><span class="style5">void </span><span class="style11">dfs</span><span class="style10">(</span><span class="style5">int </span><span class="style11">u</span><span class="style10">)
{
    </span><span class="style5">int </span><span class="style11">i</span><span class="style10">,</span><span class="style11">v</span><span class="style10">;
    </span><span class="style5">for</span><span class="style10">(</span><span class="style11">i</span><span class="style10">=</span><span class="style4">0</span><span class="style10">; </span><span class="style11">i</span><span class="style10">&lt;</span><span class="style11">SZ</span><span class="style10">(</span><span class="style11">adj</span><span class="style10">[</span><span class="style11">u</span><span class="style10">]); </span><span class="style11">i</span><span class="style10">++)
    {
        </span><span class="style11">v </span><span class="style10">= </span><span class="style11">adj</span><span class="style10">[</span><span class="style11">u</span><span class="style10">][</span><span class="style11">i</span><span class="style10">];
        </span><span class="style5">if</span><span class="style10">(</span><span class="style11">v</span><span class="style10">!=-</span><span class="style4">1</span><span class="style10">)
        {
            </span><span class="style11">adj</span><span class="style10">[</span><span class="style11">u</span><span class="style10">][</span><span class="style11">i</span><span class="style10">] = -</span><span class="style4">1</span><span class="style10">;
            </span><span class="style11">dfs</span><span class="style10">(</span><span class="style11">v</span><span class="style10">);
        }
    }
    </span><span class="style11">order</span><span class="style10">.</span><span class="style11">pb</span><span class="style10">(</span><span class="style11">u</span><span class="style10">);
}
</span><span class="style5">bool </span><span class="style11">possible</span><span class="style10">()
{
    </span><span class="style5">int </span><span class="style11">i</span><span class="style10">,</span><span class="style11">start</span><span class="style10">,</span><span class="style16">end</span><span class="style10">,</span><span class="style11">c</span><span class="style10">=</span><span class="style4">0</span><span class="style10">;
    </span><span class="style11">start </span><span class="style10">= </span><span class="style16">end </span><span class="style10">= -</span><span class="style4">1</span><span class="style10">;
    </span><span class="style5">for</span><span class="style10">(</span><span class="style11">i</span><span class="style10">=</span><span class="style4">0</span><span class="style10">; </span><span class="style11">i</span><span class="style10">&lt;</span><span class="style11">nodes</span><span class="style10">; </span><span class="style11">i</span><span class="style10">++)
    {
        </span><span class="style5">if</span><span class="style10">(</span><span class="style11">indeg</span><span class="style10">[</span><span class="style11">i</span><span class="style10">]==</span><span class="style11">outdeg</span><span class="style10">[</span><span class="style11">i</span><span class="style10">]) </span><span class="style5">continue</span><span class="style10">;
        </span><span class="style5">else if</span><span class="style10">(</span><span class="style11">indeg</span><span class="style10">[</span><span class="style11">i</span><span class="style10">]-</span><span class="style11">outdeg</span><span class="style10">[</span><span class="style11">i</span><span class="style10">]==</span><span class="style4">1</span><span class="style10">)
        {
            </span><span class="style16">end </span><span class="style10">= </span><span class="style11">i</span><span class="style10">;
            </span><span class="style11">c</span><span class="style10">++;
        }
        </span><span class="style5">else if</span><span class="style10">(</span><span class="style11">outdeg</span><span class="style10">[</span><span class="style11">i</span><span class="style10">]-</span><span class="style11">indeg</span><span class="style10">[</span><span class="style11">i</span><span class="style10">]==</span><span class="style4">1</span><span class="style10">)
        </span><span class="style0">{
            start = i;
            c++;
        }
        else return false;
    }
    if(c&gt;2) return false;
    if(start == -1)   //circuit probably
    {
        for(i=0; i&lt;nodes; i++)
            if(outdeg[i])
            {
                start = i;
                break;
            }
    }
    order.clear(); //Here Finding the
    dfs(start);//Eulear tour orderings.
    Reverse(order);
    if(SZ(order)!=nodes) return false;
//could be disconnected.
    return true;
}



Sliding Window
=================
/*
given two integers n and k which are the lengths
of the array and the sliding window.Output the minimum values
in the window at each position, from left to right, respectively.
*/
const int MAX=100009;
int store[MAX];
int Q[MAX],head,tail;
vector&lt;int&gt;MinValu;

void SlidingWindowMin(int N,int K)
{
    //N=number of elements.
    //K=windows size.
    MinValu.clear();
    head=0;tail=0;
    for(int i=1;i&lt;=N;i++)
    {
        while(head!=tail &amp;&amp; Q[head]&lt;=i-K) head++;// Cheack window size.
        while(head!=tail &amp;&amp; store[Q[tail-1]]&gt;=store[i]) tail--; // truncate the previous bigger value.
        Q[tail++]=i; // insert new elements.
        if(i&gt;=K) MinValu.pb(store[Q[head]]);
    }
    return;
}

int main()
{
    int N,K;
    scanf("%d %d",&amp;N,&amp;K);
    for(int i=1;i&lt;=N;i++) scanf("%d",&amp;store[i]);
    SlidingWindowMin(N,K); // Min value in given Window.
}

Kadane Algorithm 1D
====================
vector&lt;int&gt;v;int N;
int id1,id2;
int findMaxsum()
{
    int maxsum=-(1&lt;&lt;30);
    int currentstartindx=0,maxstartindex,maxendindx,currentsum=0;
    for(int i=0;i&lt;SZ(v);i++)
    {
        currentsum+=v[i];
        if(currentsum&gt;maxsum)
        {
            maxsum=currentsum;
            maxstartindex=currentstartindx;
            maxendindx=i;
        }
        if(currentsum&lt;0)
        {
            currentsum=0;
            currentstartindx=i+1;
        }
    }
    id1=maxstartindex;
    id2=maxendindx;
    return maxsum;
}
int main()
{
    scanf("%d",&amp;N);
    for(int i=0,x;i&lt;N;i++) {
        v.push_back(x);
    }
    int maxsum=findMaxsum();
}

Kadane Algorithm 2D
=========================================
const int MAX=109;
int grid[MAX][MAX],sum[MAX][MAX],N;

int main()
{
    while(scanf("%d",&amp;N)==1)
    {
        sum[1][0]=0;
        for(int i=1;i&lt;=N;i++)
            for(int j=1;j&lt;=N;j++)
            {
                scanf("%d",&amp;grid[i][j]);
                sum[i][j]=sum[i][j-1]+grid[i][j];
            }

        // Khadane 2D.
        int ans=-INF;
        for(int colum1=1;colum1&lt;=N;colum1++) // select first colume.
            for(int colum2=colum1;colum2&lt;=N;colum2++) // select second colume.
            {
                //khadane 1-D
                int val=0;
                for(int row=1;row&lt;=N;row++)
                {
                    val+=sum[row][colum2]-sum[row][colum1-1];
                    ans=max(ans,val);
                    if(val&lt;0) val=0;
                }
            }
        printf("%d\n",ans);
    }
    return 0;
}

Kadane Algorithm 3D
==========================================
const int MAX=100;
int X,Y,Z;
ll grid[MAX][MAX][MAX];
ll sum[MAX][MAX][MAX];

int main()
{
    int t;cin&gt;&gt;t;
    while(t--)
    {
        cin&gt;&gt;X&gt;&gt;Y&gt;&gt;Z;X++;Y++;Z++;
        FOR(i,1,X)FOR(j,1,Y)FOR(k,1,Z) scanf("%lld",&amp;grid[i][j][k]);
        mem(sum,0);
        FOR(i,1,X)FOR(j,1,Y)FOR(k,1,Z) sum[i][j][k]=sum[i][j][k-1]+grid[i][j][k];
        FOR(i,1,X)FOR(j,1,Y)FOR(k,1,Z) sum[i][j][k]+=sum[i-1][j][k];

        // khadane 3d
        ll ans=-INF;
        for(int z1=1;z1&lt;Z;z1++)
            for(int z2=z1;z2&lt;Z;z2++)
                for(int x1=1;x1&lt;X;x1++)
                    for(int x2=x1;x2&lt;X;x2++)
                    {
                        ll val=0;
                        for(int y=1;y&lt;Y;y++)
                        {
                            ll tmp=sum[x2][y][z2]-(sum[x2][y][z1-1]+sum[x1-1][y][z2])+sum[x1-1][y][z1-1];
                            val+=tmp;
                            ans=max(val,ans);
                            if(val&lt;0) val=0;
                        }
                    }
        printf("%lld\n",ans);
    }

    return 0;
}

SuffixArray (nlogn)
===================================
const int MAX=110009;
int SA[MAX],rank[MAX],lcp[MAX];
int rank2[MAX],*X,*Y,cnt[MAX];

bool cmp(int* r,int a,int b,int l,int n)
{
    if(r[a]==r[b]&amp;&amp;a+l&lt;n&amp;&amp;b+l&lt;n&amp;&amp;r[a+l]==r[b+l]) return true;
    return false;
}

void radix_sort(int n,int alphabet)
{
    for(int i=0; i&lt;alphabet; i++) cnt[i]=0;
    for(int i=0; i&lt;n; i++) cnt[X[Y[i]]]++;
    for(int i=1; i&lt;alphabet; i++) cnt[i]+=cnt[i-1];
    for(int i=n-1; i&gt;=0; i--) SA[--cnt[X[Y[i]]]]=Y[i];
}
void buildsa(const string &amp;str,int n,int alphabet)
{
    X=rank,Y=rank2;
    for(int i=0; i&lt;n; i++) X[i]=str[i],Y[i]=i;
    radix_sort(n,alphabet);
    for(int len=1; len&lt;n; len&lt;&lt;=1)
    {
        int yid=0;
        for(int i=n-len; i&lt;n; i++) Y[yid++]=i;
        for(int i=0; i&lt;n; i++) if(SA[i]&gt;=len) Y[yid++]=SA[i]-len;
        radix_sort(n,alphabet);
        swap(X,Y);
        X[SA[0]]=yid=0;
        for(int i=1; i&lt;n; i++)
        {
            X[SA[i]]=cmp(Y,SA[i],SA[i-1],len,n)?yid:++yid;
        }
        alphabet=yid+1;
        if(alphabet&gt;=n) break;
    }
    for(int i=0; i&lt;n; i++) rank[i]=X[i];
}
void buildlcp(const string &amp;str,int n)
{
    int k=0;
    lcp[0]=0;
    for(int i=0; i&lt;n; i++)
    {
        if(rank[i]==0) continue;
        k=max(k-1,0);
        int j=SA[rank[i]-1];
        while(i+k&lt;n &amp;&amp; j+k&lt;n &amp;&amp; str[i+k]==str[j+k] ) k++;
        lcp[rank[i]]=k;
    }
    return;
}

int in,n,limit;
int idx[MAX],col[200];
int ok(const string &amp;str,int mid)
{
    int i,j,k;
    for(int i=1;i&lt;n;i=j+1)
    {
        while(lcp[i]&lt;mid and i&lt;n) i++;
        if(i&gt;=n) break;
        mem(col,0);int ans=0;
        col[idx[SA[i-1]]]++; ans++;

        for(j=i;j&lt;n and lcp[j]&gt;=mid;j++)
        {
            int id=idx[SA[j]];
            if(!col[id])
            {
                col[id]++;
                ans++;
            }
        }
        if(ans&gt;in/2) return true;
    }
    return false;
}

void solve(string &amp;str,int n)
{
    int lo=1,hi=limit;
    while(lo&lt;=hi)
    {
        int mid=(lo+hi)/2;
        if(ok(str,mid))
        {
            ans=mid;
            lo=mid+1;
        }
        else hi=mid-1;
    }
    return ans;
}

int main()
{
    string str;
    cin&gt;&gt;str;
    n=SZ(str);
    buildsa(str,n,250);
    buildlcp(str,n);
    cout&lt;&lt;solve(str,n)&lt;&lt;endl;
}</span></span>
</code></pre>
</body>
</html>
